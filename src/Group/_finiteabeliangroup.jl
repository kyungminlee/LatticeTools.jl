
export FiniteAbelianGroup

export order
export n_elements

export group_product
export generate_subgroup
export issubgroup
export group_modulo
export minimal_generating_set


struct FiniteAbelianGroup <: AbstractAbelianGroup
    multiplication_table::Matrix{Int}
    period_lengths::Vector{Int}

    function FiniteAbelianGroup(mtab::AbstractMatrix{<:Integer})
        n_elements = size(mtab, 1)
        size(mtab, 2) != n_elements && throw(ArgumentError("multiplication table should be a square matrix"))
        elements = BitSet(1:n_elements)
        for i in 1:n_elements
            BitSet(mtab[:,i]) != elements && throw(ArgumentError("multiplication table not a group"))
            BitSet(mtab[i,:]) != elements && throw(ArgumentError("multiplication table not a group"))
        end
        mtab != transpose(mtab) && throw(ArgumentError("multiplication table not commutative"))

        period_lengths = zeros(Int, n_elements)
        for idx in 1:n_elements
            jdx = idx
            for i in 1:n_elements
                if jdx == 1
                    period_lengths[idx] = i
                    break
                end
                jdx = mtab[jdx, idx]
            end
        end

        new(mtab, period_lengths)
    end
end

group_order(group::FiniteAbelianGroup) = size(group.multiplication_table, 1)
isabelian(group::FiniteAbelianGroup) = true


"""
    group_product(group, lhs, rhs)
"""
function group_product(group::FiniteAbelianGroup, lhs::Integer, rhs::Integer)
    return group.multiplication_table[lhs, rhs]
end


function group_product(group::FiniteAbelianGroup,
                       lhs::AbstractSet{<:Integer}, rhs::Integer)
    return BitSet([group_product(group, x, rhs) for x in lhs])
end


function group_product(group::FiniteAbelianGroup,
                       lhs::Integer, rhs::AbstractSet{<:Integer})
    return BitSet([group_product(group, lhs, x) for x in rhs])
end


function group_product(group::FiniteAbelianGroup,
                       lhs::AbstractSet{<:Integer},
                       rhs::AbstractSet{<:Integer})
    return BitSet([group_product(group, x, y) for x in lhs for y in rhs])
end


"""
    generate_subgroup(mtab, idx)

subgroup generated by `generators`. ⟨ {g} ⟩
"""
function generate_subgroup(group::FiniteAbelianGroup, idx::Integer)
    out = BitSet([1])
    jdx = idx
    for i in 1:group_order(group)
        jdx == 1 && return out
        push!(out, jdx)
        jdx = group_product(group, jdx, idx)
    end
    assert(false)
    return BitSet()
end


"""
    generate_subgroup(mtab, generators)

subgroup generated by `generators`. ⟨ S ⟩

"""
function generate_subgroup(group::FiniteAbelianGroup,
                           generators::G) where {G<:Union{<:AbstractSet{<:Integer},
                                                          <:AbstractVector{<:Integer}}}
    change = true
    subgroup = BitSet(generators)
    while change
        change = false
        for g1 in generators, g2 in subgroup
            g3 = group_product(group, g1, g2)
            if !(g3 in subgroup)
                change = true
                push!(subgroup, g3)
            end
        end
    end
    return subgroup
end


"""
    generate_subgroup(group, generators...)
"""
function generate_subgroup(group::FiniteAbelianGroup, generators::Integer...)
    return generate_subgroup(group, generators)
end


"""
    issubgroup(mtab, subset)
"""
function issubgroup(group::FiniteAbelianGroup,
                    subset::AbstractSet{<:Integer})
    return all(group_product(group, x, y) in subset for x in subset for y in subset)
end


function group_modulo(group::FiniteAbelianGroup,
                      subgroup::AbstractSet{<:Integer})
    n = size(mtab, 1)
    coset = BitSet(subgroup)
    cosets = [coset]

    remaining = collect(n:-1:2)
    setdiff!(remaining, coset)
    while !isempty(remaining)
        g = pop!(remaining)
        coset = group_product(mtab, subgroup, g)
        setdiff!(remaining, coset)
        push!(cosets, coset)
    end
    return cosets
end


function minimal_generating_set(group::FiniteAbelianGroup)
    ord_group ::Int = group_order(group)
    element_queue ::Vector{Tuple{Int, Int}} = collect(enumerate(group.period_lengths))
    sort!(element_queue, by=item->(-item[2], item[1]))

    function factorize(generators::Vector{Int}, span::BitSet, queue_begin::Int)::Bool
        ord_span = length(span)
        ord_span == ord_group && return true
        for i in queue_begin:ord_group
            (g, pl) = element_queue[i]
            if ord_group % (ord_span * pl) == 0
                new_span = generate_subgroup(group, group_product(group, span, g))
                if length(new_span) == ord_span * pl
                    push!(generators, g)
                    factorize(generators, new_span, i+1) && return true
                    pop!(generators)
                end
            end
        end
        return false
    end

    generators = Int[]
    sizehint!(generators, ord_group)
    factorize(generators, BitSet([1]), 1)
    return generators
end
